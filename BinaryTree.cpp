#include "BinaryTree.h"

// удаление элемента 
void BinaryTree::remove(Node* node) {
    if (node) {
        //с помощью рекурсии пробегаемся по обоим веткам 
        // исходящим от переданной, после чего удаляем
        // сам переданный элемент делитом
        remove(node->left);
        remove(node->right);
        delete node;
    }
}

//поиск самого левого элемента
Node* BinaryTree::min(Node* node) const {
    // с помощью цикла идем каждый раз переходя на левое ответвление пока
    // не достигнем крайнего элемента, который всегда
    // будет являться минимальным элементов всего дерева
    while (node && node->left)
    {
        node = node->left;
    }

    return node;
}

//поиск самого правого
Node* BinaryTree::max(Node* node) const {
    // точно также как и с нахождением минимального, 
    // но идём до края правой ветки
    while (node && node->right)
    {
        node = node->right;
    }

    return node;
}

//поиск следующего элемента
Node* BinaryTree::next(Node* node) const {

    // если нод равен нуллптр то сразу происходит 
    // окончание метода возвращением нуллптра

    if (!node) return nullptr;

    // создаем переменую в которой будем хранить 
    // значение родительского узла по отношению к переданному

    Node* parent = nullptr;

    // если есть правая ветка, идем по ней и находим минимальный 
    // относительно неё который всегда будет являться 
    // наименьшим из ключей больших чем переданный

    if (node->right) {
        return min(node->right);
    }

    // если правого ответвления нет, передаем в перент
    // родительский указатель переданного узла

    parent = node->parent;

    // далее после этого пока парент не равен нуллптр и пока 
    // оно находится справа от родителя (тобишь пока родитель меньше
    // переданого узла) перенту присваивается его родительский

    while (parent && node == parent->right) {
        node = parent;
        parent = parent->parent;
    }

    // когда нод наконец становится левым от родительского узла 
    // (тоесть родительский больше чем переданный нод) и цикл прекращается
    // возаращается найденный родительский узел

    return parent;
}

Node* BinaryTree::prev(Node* node) const {
    // проверка не передан ли нуллптр
    if (!node) return nullptr;

    Node* parent = nullptr;

    // то же самое что с некстом но если есть левое отвелвление
    // а не правое

    if (node->left) {
        return max(node->left);
    }

    parent = node->parent;

    // то же самое что и с некстом, но пока родительский не станет правым
    // (то есть гарантированно не будет меньше переданного

    while (parent && node == parent->left) {
        node = parent;
        parent = parent->parent;
    }

    return parent;
}

Node* BinaryTree::search(Node* node, int key) const
{
    // пока нод не равен нуллптр цикл продолжается
    while (node)
    {
        // если ключ, переданный нам, равен ключу
        // из текущего узла, то мы возвращаем адрес
        // на этот же текущий узел
        if (key == node->key)
        {
            return node;
        }
        
        // нод меняется в зависимочти от переданного искомого
        // ключа, если ключ меньше нод, то мы идем в левое ответвление
        // а если больше, то очевидно в правое и так пока на
        // из прерыдущего цикла не выполнится условие
        node = (key < node->key) ? node->left : node->right;
    }

    // если условие так и не выполнилось, возвращаем нуллптр
    return nullptr;
}

void BinaryTree::print(Node* node) const
{
    // проверка если переданный узел равен нуллптр, метод завершает работу
    if (!node) return;

    // происходит рекурсия, при которой сначала программа
    // доходит до самого левого элемента, далее до его родителя
    // далее до правого ответвления родителя самого правого и так пока
    // все рекурсии не свернутся

    // сначала левый а потом правый для соблюдения порядка вывода
    // иначе вывод будет не сортирован

    print(node->left);

    cout << "\nНомер машины: " << node->key << " ";

    // вызов метода который выводит все нарушения
    node->print_All();
    cout << "\n\n";

    print(node->right);

}

void BinaryTree::print_range(Node* node, int left, int right) const
{
    if (!node) return;

    print_range(node->left, left, right);

    // тоже самое что и с обычным выводом, но вывод 
    // происходит только в случае если число подходит под
    // переданный ранг

    if (left <= node->key && node->key <= right)
    {
        cout << "\nНомер машины: " << node->key << " ";
        node->print_All();
        cout << "\n\n";
    }

    print_range(node->right, left, right);
}

void BinaryTree::print_key(int num) const
{
    // основная причина по которой в методе поиска 
    // значение не константное это то, что я использую
    // его чтобы выводить значение по искомому ключу в этом методе
    Node* node = search(root, num);

    cout << "\nНомер машины: " << node->key << " ";
    node->print_All();
    cout << "\n\n";
}

void BinaryTree::insert(int value, string viol)
{
    // исключение
    try {
        // сразу выбрасывает исключение в случае если такой ключ существует
        // то есть значение которое вернул метод поиска
        // не равно нуллптр. выбрасывает кастомную ошибку класса 
        if (search(root, value))
        {
            throw KeyAlreadyExists("\n\nКлюч который вы пытаетесь записать уже существует.\n\n");
        }
        Node* newNode = new Node(value, viol);
        Node* current = root;
        Node* parent = nullptr;

        // если корень дерева равен нуллптр, что означает что добавляемый узел
        // первый, то руту присваивается его адрес и метод завершается
        if (!root) {
            root = newNode;

            return;
        }

        // пока текущий буфер не равен нуллптр цикл продолжает работу
        while (current) {
            // сохранение текущего буфера в буфер перент
            // перед изменениями в иф и элс
            parent = current;

            // если ключ переданный для заполнения вставляемого элемента
            // меньше чем ключ текущего, переход в левую ветку
            if (value < current->key) {
                current = current->left;
            }

            // в другом случае идёт переход в правую ветку
            else {
                current = current->right;
            }
        }

        // после того как мы нашли место для вставки
        // и текущий индекс стал нуллптром, добавляемому узлу
        // в родительский указатель присваивается адрес указателя род.
        // буфера который мы соханили в прошлом цикле
        newNode->parent = parent;

        //теперь идёт вставка в правое или левое ответвление
        // найденного нужного родителя в зависимости от того, больше
        // или меньше ключ добавляемого элемента ключа родителя
        if (value < parent->key) {
            parent->left = newNode;
        }
        else {
            parent->right = newNode;
        }
    }

    // ловит ошибку и выводит её, после чего добавляет
    // нарушение из переданной для вставки переменной
    // к уже сущетсвюему узлу с таким же ключом
    catch (KeyAlreadyExists& obj)
    {
        cout << obj.what();

        search(root, value)->add_viol(viol);
    }
}

void BinaryTree::remove_tree(Node* node) {
    if (!node) return;

    // если узел который необходимо удалить равен руту, значит
    // рут просто удаляется с помощью метода и к нему присваивается нуллптр
    if (node == root) {
        remove(root);
        root = nullptr;
    }

    // в противном случае мы определяем каким, правым или левым, ответвлением
    // от своего родителя является преданный нам узел и присваиваем
    // атрибуту указателя на это ответвление нуллптр
    else {
        if (node->parent->left == node) {
            node->parent->left = nullptr;
        }
        else {
            node->parent->right = nullptr;
        }

        // после чего вызываем метод удаления узла
        remove(node);
    }
}

void BinaryTree::remove_node(Node*& node)
{
    if (!node) return;

    //если у переданного узла нету левого ответвления (=нуллптр)
    if (!node->left)
    {
        // новому буфферному значению присваивается правое ответвление
        Node* temp = node->right;

        // если буффер не равен нуллптр, его родителю (переданному ноду)
        // присваивается родитель переданного нода
        if (temp)
        {
            temp->parent = node->parent;
        }

        // сам переданный узел нод удаляется
        delete node;

        // ноду присваивается темп, то есть правое ответвление смещается на 1
        // ступень выше, заменяя удаляемый обьект собой
        node = temp;
    }
    else if (!node->right)
    {
        // происходит всё то же самое, только в этом случае если
        // у переданного нода есть только левое ответвление, а не правое
        Node* temp = node->left;

        if (temp)
        {
            temp->parent = node->parent;
        }

        delete node;

        node = temp;
    }
    else
    {
        // если у нода присутствуют оба ответвления, то удаление невозможно
        // и буферу присваивается значение следующего элемента дерева
        // то есть правого ответвления
        Node* next_node = next(node);

        // переданному узлу присваивается значение следующего элемента
        node->key = next_node->key;

        // следующий элемент удаляется (возможно начало рекурсии если у след. элемента
        // также есть оба ответвления
        remove_node(next_node);
    }
}

// деструктор класса бинарного дерева
BinaryTree::~BinaryTree() {
    remove(root);
}


// метод из нода, который выводит все нарушения по списку
void Node::print_All() const
{
    // буфер для пробега по элементам
    violation_list* buff = violations;
    // счётчик для пронумерованного вывода на экран
    int count = 1;

    // пока буфер не станет равен нуллптр и не будет
    // достигнут конец списка происходит вывод содержимого
    while (buff != nullptr)
    {
        cout << "\nНарушение №" << count << ": " << buff->violation;
        count++;
        buff = buff->next;
    }
}

// метод для добавления нарушения, который тут вызывается 
// исключением если ключ уже существует

void Node::add_viol(string viol)
{
    // буфер для прохождения по всем элементам исключений
    // этого ключа, чтобы найти последний
    violation_list* buff = violations;

    // новое нарушение, которое будет добавлено в этот
    // односвязный список как последнее нарушение
    violation_list* new_viol = new violation_list{ viol };

    // нахождение последнего элемента списка нарушений
    // у которого атрибут некст равен нуллптру
    while (buff->next != nullptr)
    {
        buff = buff->next;
    }

    // присвоение атрибуту некст найденного элемента
    // указатель на новый обьект с новым нарушением
    buff->next = new_viol;
}


violation_list& violation_list::operator=(violation_list& ptr)
{
    violation = ptr.violation;

    next = ptr.next;

    return *this;
}